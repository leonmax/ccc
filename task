FRONT = vector.new( 0,  1,  0)
RIGHT = vector.new( 1,  0,  0)
BACK  = vector.new( 0, -1,  0)
LEFT  = vector.new(-1,  0,  0)
UP    = vector.new( 0,  0,  1)
DOWN  = vector.new( 0,  0, -1)

Task = {}
Task.__index = Task

function Task.new(actor)
  local self = setmetatable({}, Task)
  self.pos = vector.new(0, 0, 0)
  self.dir = FRONT
  self.sPos = vector.new(0, 0, 0)
  self.sDir = FRONT
  self.actor = actor
  self.coordinate = self:locate()
  return self
end

function Task.locate(self, inputCoordinate)
  local x, y, z = gps.locate(5)
  if x ~= nil then
    self.coordinate = vector.new(x, y, z)
    print("I am at "..self.coordinate:tostring())
  elseif inputCoordinate ~= nil and inputCoordinate.x ~= nil then
    self.coordinate = inputCoordinate
    print("Manually input coordinate "..self.coordinate:tostring())
  elseif self.coordinate == nil or self.coordinate.x == nil then
    self.coordinate = vector.new(0, 0, 0)
    print("Totally lost, assume at "..self.coordinate:tostring())
  end
  return self.coordinate
end

function relativePos(coordinate)
  gps.locate()
end

function Task.forward(self)
  local result = turtle.forward()
  if result then
    self.pos = self.pos + self.dir
    self.coordinate = self.coordinate + self.dir
    -- print("moved to "..self.pos:tostring())
    self.actor:act()
    return 1
  else
    return 0
  end
end

function Task.back(self)
  local result = turtle.back()
  if result then
    self.pos = self.pos - self.dir
    self.coordinate = self.coordinate - self.dir
    -- print("moved to "..self.pos:tostring())
    self.actor:act()
    return -1
  else
    return 0
  end
end

function Task.up(self, step)
  if step == nil then step = 1 end
  local i = 0
  while i < step do
    local result = turtle.up()
    if result then
      self.pos = self.pos + UP
      self.coordinate = self.coordinate - UP
      -- print("moved to "..self.pos:tostring())
      self.actor:act()
      i = i + 1
    else
      return 0
    end
  end
  print("ascend "..i.." blocks")
  return i
end

function Task.down(self, step)
  if step == nil then step = -1 end
  local i = 0
  while i > step do
    local result = turtle.down()
    if result then
      self.pos = self.pos + DOWN
      self.coordinate = self.coordinate - DOWN
      -- print("moved to "..self.pos:tostring())
      self.actor:act()
      i = i - 1
    else
      break
    end
  end
  print("descend "..i.." blocks")
  return i
end

function Task.move(self, distance)
  local moved = 0
  local step = math.abs(distance)
  for i=1,step do
    local thismove = 0
    if distance >= 0 then
      thismove = self:forward()
    else
      thismove = self:back()
    end
    if thismove == 0 then
      break
    else
      moved = moved + thismove
    end
  end
  print("moved "..moved.." blocks")
  return moved
end

function Task.right(self, step)
  if self.dir == LEFT then
    self.dir = FRONT
    print("face original front")
  elseif self.dir == FRONT then
    self.dir = RIGHT
    print("face original right")
  elseif self.dir == RIGHT then
    self.dir = BACK
    print("face original back")
  elseif self.dir == BACK then
    self.dir = LEFT
    print("face original left")
  end
  turtle.turnRight()

  if step == nil then step = 0 end
  self:move(step)

end

function Task.left(self, step)
  if self.dir == LEFT then
    self.dir = BACK
    print("face original back")
  elseif self.dir == BACK then
    self.dir = RIGHT
    print("face original right")
  elseif self.dir == RIGHT then
    self.dir = FRONT
    print("face original front")
  elseif self.dir == FRONT then
    self.dir = LEFT
    print("face original left")
  end
  turtle.turnLeft()

  if step == nil then step = 0 end
  self:move(step)
end

function Task.cover(self, relativeX, relativeY)
  local row = 0
  print("covering "..relativeX.." X "..relativeY)
  while row < relativeX do
    self:move(relativeY - 1)
    row = row + 1
    self:right()
    if row < relativeX then
      self:forward()
    end
    self:right()
    self:move(relativeY - 1)
    row = row + 1
    self:left()
    if row < relativeX then
      self:forward()
    end
    self:left()
  end
  self:left()
  self:move(relativeX - 1)
  self:right()
  print("final pos: ("..self.pos:tostring()..") dir: ("..self.dir:tostring()..")")
  print("final coordinate: "..self.coordinate:tostring())
end

function Task.to(self, relativeCo)
  self:move(relativeCo.y - self.pos.y)
  if relativeCo.x - self.pos.x ~= 0 then
    self:right(relativeCo.x - self.pos.x)
    self:left()
  end
  if relativeCo.z > 0 then
    self:up(relativeCo.z)
  elseif relativeCo.z < 0 then
    self:down(relativeCo.z)
  end
  print("final pos: ("..self.pos:tostring()..") dir: ("..self.dir:tostring()..")")
  print("final coordinate: "..self.coordinate:tostring())
end

return Task
